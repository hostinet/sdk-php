<?php
/**
 * The Hostinet API Client.
 * @package HostinetApi
 */

class HostinetApi {
    private $appKey, $appSecret;
    private $host = 'https://www.hostinet.com/api/';
    private $useragent = 'hostinet-api v0.3-beta';
    private $http_info = array();
    private $timeout = 3;
    private $connecttimeout = 3;
    private $ssl_verifypeer = true;
    private $format = 'json';
    private $version = 1.0;
    private $token = null;
    /**
     * Constructor
     * @param array $config
     */
    public function __construct($config) {
        if(func_num_args() == 2) {
            $config = array();
            $config['appKey'] = func_get_arg(0);
            $config['appSecret'] = func_get_arg(1);
        }            
        if($config) {
            $this->appKey = $config['appKey'];
            $this->appSecret = $config['appSecret'];
        }
    }
    /**
     * Upload a file
     * @param string $path_file
     * @return object
     */
    public function upload($path_file){
        if(!$path_file || !is_file($path_file) || !is_readable($path_file)) {
            return false;
        }
        $args = array(
            'file' => "@{$path_file}",
        );
        return $this->request('POST', 'tool/upload', $args);
    }
    /**
     * POST data
     * @param string $path
     * @param array $params
     * @return object
     */
    public function post($path, $params){
        return $this->request('POST', $path, $params);
    }
    /**
     * PUT data
     * @param string $path
     * @param array $params
     * @return object
     */
    public function put($path, $params){
        return $this->request('PUT', $path, $params);
    }
    /**
     * DELETE data
     * @param string $path
     * @param array $params
     * @return object
     */
    public function delete($path, $params){
        return $this->request('DELETE', $path, $params);
    }
    /**
     * GET data
     * @param string $path
     * @param array $params
     * @return object
     */
    public function get($path, $params = array()){
        return $this->request('GET', $path, $params);
    }
    /**
     * REQUEST data
     * @param string $method
     * @param string $path
     * @param array $params
     * @return object
     */
    public function request($method, $path, $params = ''){        
        $path = parse_url($path, PHP_URL_PATH);
        $args = parse_url($path, PHP_URL_QUERY);
        $p = explode("/", trim($path, '/'));
        $path = implode("/", $p) .'/';
        if($args) {
            $path .= "?{$args}";
        }
        
        $params['version'] = $this->version;
        $files = array();
        foreach ($params as $k => $v) {
            if(is_string($v) && $v[0] == '@' && file_exists(substr($v, 1))) {
                $files[$k] = $v;
                unset($params[$k]);
            }
        }
        
        if(!empty($files)) {
            foreach ($files as $name => $value) {
                $params[$name] = $value;
            }
        }
        if($method == 'GET' && $params) {
            $params = self::build_http_query($params);
            $path .= '?' . $params;
            $params = null;
        }
        $response = $this->http($method, $path, $params);
        if($response && $this->format == 'json') {
            $response = json_decode($response);
        }
        return $response;
    }
    /**
     * Send request
     * @param string $method
     * @param string $path
     * @param array $params
     * @return object
     */
    public function http($method, $path, $params){
        $this->http_info = array();
        $url = $this->host . $path;
        if(!$this->token) {
            $this->auth();
        }
        $time = time();
        $headers = array();
        if($this->token) {
            $headers[] = 'token: ' . $this->token;
        } else {
            $headers[] = 'appKey: ' . $this->appKey;
            $headers[] = 'appRandom: ' . $time;
            $headers[] = 'appHash: ' . md5($this->appKey . $this->appSecret . $time);
        }
        $headers[] = 'Expect: ';
        
        $ci = curl_init();
        /* Curl settings */
        curl_setopt($ci, CURLOPT_USERAGENT, $this->useragent);
        curl_setopt($ci, CURLOPT_CONNECTTIMEOUT, $this->connecttimeout);
        curl_setopt($ci, CURLOPT_TIMEOUT, $this->timeout);
        curl_setopt($ci, CURLOPT_RETURNTRANSFER, TRUE);
        curl_setopt($ci, CURLOPT_HTTPHEADER, $headers);
        curl_setopt($ci, CURLOPT_SSL_VERIFYPEER, $this->ssl_verifypeer);
        curl_setopt($ci, CURLOPT_HEADERFUNCTION, array($this, 'getHeader'));
        curl_setopt($ci, CURLOPT_HEADER, FALSE);
        curl_setopt($ci, CURLOPT_VERBOSE, FALSE);
        curl_setopt($ci, CURLOPT_FOLLOWLOCATION, TRUE);

        switch ($method) {
          case 'POST':
            curl_setopt($ci, CURLOPT_POST, TRUE);
            if (!empty($params)) {
              curl_setopt($ci, CURLOPT_POSTFIELDS, $params);
            }
            break;
        case 'DELETE':
            curl_setopt($ci, CURLOPT_CUSTOMREQUEST, 'DELETE');
            if (!empty($params)) {
              $url = "{$url}?{$params}";
            }
            break;
        case 'PUT':
            curl_setopt($ci, CURLOPT_CUSTOMREQUEST, 'PUT');
            if (!empty($params)) {
              $url = "{$url}?{$params}";
            }
            break;
        }

        curl_setopt($ci, CURLOPT_URL, $url);
        $response = curl_exec($ci);
        $this->http_code = curl_getinfo($ci, CURLINFO_HTTP_CODE);
        $this->http_info = array_merge($this->http_info, curl_getinfo($ci));
        $this->url = $url;
        curl_close ($ci);
        return $response;
    }
    /**
     * Get the token
     * @return object
     */
    public function auth(){
        $this->http_info = array();
        $url = $this->host . 'auth/';
        $headers = array();
        $headers[] = 'Expect: ';
        $params = array(
            'appkey' => $this->appKey,
            'appsecret' => $this->appSecret,
        );
        $ci = curl_init();
        /* Curl settings */
        curl_setopt($ci, CURLOPT_USERAGENT, $this->useragent);
        curl_setopt($ci, CURLOPT_CONNECTTIMEOUT, $this->connecttimeout);
        curl_setopt($ci, CURLOPT_TIMEOUT, $this->timeout);
        curl_setopt($ci, CURLOPT_RETURNTRANSFER, TRUE);
        curl_setopt($ci, CURLOPT_HTTPHEADER, $headers);
        curl_setopt($ci, CURLOPT_SSL_VERIFYPEER, $this->ssl_verifypeer);
        curl_setopt($ci, CURLOPT_HEADERFUNCTION, array($this, 'getHeader'));
        curl_setopt($ci, CURLOPT_HEADER, FALSE);
        curl_setopt($ci, CURLOPT_VERBOSE, FALSE);
        curl_setopt($ci, CURLOPT_FOLLOWLOCATION, TRUE);

        curl_setopt($ci, CURLOPT_POST, TRUE);
        if (!empty($params)) {
          curl_setopt($ci, CURLOPT_POSTFIELDS, $params);
        }
        curl_setopt($ci, CURLOPT_URL, $url);
        $response = curl_exec($ci);
        $this->http_code = curl_getinfo($ci, CURLINFO_HTTP_CODE);
        $this->http_info = array_merge($this->http_info, curl_getinfo($ci));
        $this->url = $url;
        curl_close ($ci);
        $json = json_decode($response);
        if($json && $json->ok && $json->token) {
            $this->token = $json->token;
        }
        return $response;
    }
    public function getHeader($ch, $header) {
        $i = strpos($header, ':');
        if (!empty($i)) {
            $key = str_replace('-', '_', strtolower(substr($header, 0, $i)));
            $value = trim(substr($header, $i + 2));
            $this->http_header[$key] = $value;
        }
        return strlen($header);
    }
    /**
     * Encode the data
     * @param array/string $input
     * @return string
     */
    public static function urlencode_rfc3986($input) {
        if (is_array($input)) {
            return array_map(array(__CLASS__, 'urlencode_rfc3986'), $input);
        } else if (is_scalar($input)) {
            return str_replace('+', ' ', str_replace('%7E', '~', rawurlencode($input)));
        }
        return '';
    }
    /**
     * Encode and convert the data in string
     * @param string $input
     * @return string
     */
    public static function build_http_query($params) {
        if (!$params)
            return '';
        $keys = self::urlencode_rfc3986(array_keys($params));
        $values = self::urlencode_rfc3986(array_values($params));
        $params = array_combine($keys, $values);
        uksort($params, 'strcmp');
        $pairs = array();
        foreach ($params as $parameter => $value) {
            if (is_array($value)) {
                natsort($value);
                foreach ($value as $duplicate_value) {
                    $pairs[] = $parameter . '[]=' . $duplicate_value;
                }
            } else {
                $pairs[] = $parameter . '=' . $value;
            }
        }
        return implode('&', $pairs);
    }
}
